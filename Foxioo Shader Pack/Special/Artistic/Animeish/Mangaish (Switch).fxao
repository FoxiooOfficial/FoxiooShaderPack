/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.0 (31.08.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
	In = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _ColorSteps;
uniform float _LumMult;
uniform float _DotsLumSteps;
uniform float _MixingManga;
uniform float _DotsTranparent;
uniform float _DotsCoverage;
uniform float _DotsSize;
uniform float _DotsAntialiasing;
uniform bool _Blending_Mode;
uniform bool _DotsInvertedPattern;
uniform bool _DotsInvertedColors;
uniform vec4 _ColorLight;
uniform vec4 _ColorShadow;
uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

float Fun_FMod(float _Value, float _Denom)
{
    return _Value - _Denom * floor(_Value / _Denom);
}

float Fun_Quantize(float _Value, float _Steps)
{
    if (_Steps <= 0.0)  
        return step(0.5, _Value);
    else                
        return floor(_Value * _Steps + 0.5) / _Steps;
}

vec3 Fun_Quantize_3(vec3 _Value, float _Steps)
{
    return vec3(Fun_Quantize(_Value.r, _Steps),
                Fun_Quantize(_Value.g, _Steps),
                Fun_Quantize(_Value.b, _Steps));
}

float Fun_PatternDot(vec2 UV, float _Size, float _Lum)
{
    vec2 _UV_Res = UV / vec2(fPixelWidth, fPixelHeight);
    vec2 _Grid = _UV_Res / _Size;

    float _Row = floor(_Grid.y);
    if (Fun_FMod(_Row, 2.0) == 1.0) {   
        _Grid.x += 0.5;  
    }

    vec2 _Cell = fract(_Grid);

    float _InvPattern = _DotsInvertedPattern ? 1.0 : 0.0;
    float _Dist = abs(_InvPattern - length(_Cell - 0.5)) * _DotsCoverage;

    float _Render = _Lum;
    float _Result = smoothstep(_Render - _DotsAntialiasing, _Render + _DotsAntialiasing, _Dist);

    return 1.0 - _Result * _DotsTranparent;
}


void main(void)
{
    vec2 In_Background = vec2(In.x, 1.0 - In.y);

    vec4 _Render_Texture = texture2D(imgTexture, In) * blendColor;
    vec4 _Render_Background = _Is_Pre_296_Build ? texture2D(bckgTexture, In_Background) : texture2D(bckgTexture, In);

    vec4 _Result = _Blending_Mode ? _Render_Background : _Render_Texture;
    vec4 _Render = _Result;

    	float _Lum = (_Result.r * 0.299 + _Result.g * 0.587 + _Result.b * 0.114) * _LumMult;

    	float _DotPatten = Fun_PatternDot(In, _DotsSize, Fun_Quantize(_Lum, _DotsLumSteps));
    	_Result.rgb = vec3(_DotPatten);
    	_Result.rgb = mix(_Result.rgb, _Result.rgb * Fun_Quantize_3(_Render.rgb * _LumMult, _ColorSteps), _MixingManga);
		_Result.rgb = abs(float(_DotsInvertedColors) - _Result.rgb);

    _Result.rgb = mix(_ColorShadow.rgb, _ColorLight.rgb, (_Result.r * 0.299 + _Result.g * 0.587 + _Result.b * 0.114));
    _Result.rgb = mix(_Render.rgb, _Result.rgb, _Mixing);

    _Result.a = _Render_Texture.a;
    gl_FragColor = _Result;
}

//@End