/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.3 (04.01.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
	In = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _Border;
uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

float Fun_Lum (vec4 _Result) { return (0.2126 * _Result.r + 0.7152 * _Result.g + 0.0722 * _Result.b) * _Result.a; }

float Fun_OuterOutline(vec2 In)
{
    vec2 _PX = vec2(fPixelWidth, fPixelHeight);
    float _Alpha = texture2D(imgTexture, In).a * blendColor.a;

    float aL = texture2D(imgTexture, In + vec2(-_PX.x * _Border, 0.0)).a * blendColor.a;
    float aR = texture2D(imgTexture, In + vec2( _PX.x * _Border, 0.0)).a * blendColor.a;
    float aU = texture2D(imgTexture, In + vec2(0.0, -_PX.y * _Border)).a * blendColor.a;
    float aD = texture2D(imgTexture, In + vec2(0.0,  _PX.y * _Border)).a * blendColor.a;

    return step(0.01, aL + aR + aU + aD) * (1.0 - _Alpha) * ( (aL + aR + aU + aD));
}

vec3 Fun_Outline(vec2 In, vec3 _Color)
{
    vec2 _PX = vec2(fPixelWidth, fPixelHeight);
    float _Alpha = texture2D(imgTexture, In).a * blendColor.a;

    float aL1 = texture2D(imgTexture, In + vec2(-_PX.x * _Border, 0.0)).a * blendColor.a;
    float aR1 = texture2D(imgTexture, In + vec2( _PX.x * _Border, 0.0)).a * blendColor.a;
    float aU1 = texture2D(imgTexture, In + vec2(0.0, -_PX.y * _Border)).a * blendColor.a;
    float aD1 = texture2D(imgTexture, In + vec2(0.0,  _PX.y * _Border)).a * blendColor.a;

    float aL2 = texture2D(imgTexture, In + vec2(-_PX.x * 2.0 * _Border, 0.0)).a * blendColor.a;
    float aR2 = texture2D(imgTexture, In + vec2( _PX.x * 2.0 * _Border, 0.0)).a * blendColor.a;
    float aU2 = texture2D(imgTexture, In + vec2(0.0, -_PX.y * 2.0 * _Border)).a * blendColor.a;
    float aD2 = texture2D(imgTexture, In + vec2(0.0,  _PX.y * 2.0 * _Border)).a * blendColor.a;

        float _Edge1  = step(0.01, abs(aL1 - _Alpha) + abs(aR1 - _Alpha) + abs(aU1 - _Alpha) + abs(aD1 - _Alpha));
        float _Edge2 = step(0.01, abs(aL2 - _Alpha) + abs(aR2 - _Alpha) + abs(aU2 - _Alpha) + abs(aD2 - _Alpha));

    return mix(_Color * 0.5, vec3(1.0, 1.0, 1.0), _Edge1 * _Alpha) + _Edge2 * 0.25;
}

float Fun_Random(vec2 In)
{
    return fract(sin(dot(In, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 In_Background = In;

        if(_Is_Pre_296_Build)
            In_Background = vec2(In.x, 1.0 - In.y);

    vec4 _Render_Texture = texture2D(imgTexture, In) * blendColor;
    vec4 _Render_Background = texture2D(bckgTexture, In_Background);

    float _Rand = Fun_Random(In + _Render_Texture.rb + _Render_Texture.bg + _Render_Background.rg + _Render_Background.br);

            float _Lum = Fun_Lum(_Render_Texture);
            float _Lum_Background = Fun_Lum(_Render_Background);

            vec3 _Space = mix(vec3(0.0, 0.0, 0.0), vec3(0.15, 0.05, 0.25), _Lum);
            _Space += (_Space * (texture2D(bckgTexture, In + tan(_Lum) * _Lum * 0.25 - tan(_Lum_Background) * 0.25 - _Rand).rgb) * 1.5);
            _Space *= 0.5;

                float _Render_Background_Void_R = texture2D(bckgTexture, In + (_Render_Background.r * (1.0 - _Render_Texture.r) + _Rand) * 0.1).r;
                float _Render_Background_Void_G = texture2D(bckgTexture, In + (_Render_Background.g * (1.0 - _Render_Texture.g) + _Rand) * 0.1).b;
                float _Render_Background_Void_B = texture2D(bckgTexture, In + (_Render_Background.b * (1.0 - _Render_Texture.b) + _Rand) * 0.1).b;

                _Space = mix(_Space, _Space + vec3(_Render_Background_Void_R, _Render_Background_Void_G, _Render_Background_Void_B) * vec3(0.15, 0.05, 0.25), 1.0 - _Lum);


            vec4 _Result = _Render_Texture;
            _Result.rgb = mix(_Render_Texture.rgb, _Space + vec3(pow(Fun_Random(In + _Space.rb + _Space.bg + _Render_Background.rg + _Render_Background.br + _Rand), 255.0)), _Mixing);
            _Result.rgb += (Fun_Outline(In, _Space) + vec3(pow(_Lum, 6.0)) * clamp(_Mixing, 0.0, 1.0));

            vec3 _Cosmos = vec3(pow(Fun_Random(In), 128.0)) * 0.5;
            _Result = mix(vec4(_Cosmos.rgb, 1.0), _Result, 1.0 - vec4(pow(Fun_OuterOutline(In), 4.0)));

            _Result = mix(_Render_Texture, _Result, _Mixing);

    gl_FragColor = _Result;
}

//@End
