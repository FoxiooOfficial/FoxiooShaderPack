/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.0 (06.09.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
	In = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _RingingMixing;

uniform float _RainbowFreq;
uniform float _RainbowStrength;

uniform float _Saturation;
uniform float _Value;

uniform float _Seed;
uniform float _RainbowErrorNoise;
uniform float _NoiseBig;
uniform float _NoiseSmall;

uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

float Fun_FMod(float _Value, float _Denom)
{
    return _Value - _Denom * floor(_Value / _Denom);
}


float Fun_Luminance(vec3 _Result)
{
    const float _Kr = 0.299;
    const float _Kg = 0.587;
    const float _Kb = 0.114;

    float _Y = _Kr * _Result.r + _Kg * _Result.g + _Kb * _Result.b;

    return _Y;
}

vec3 Fun_RGB_YCbCr(vec3 _Result)
{
    const float _Kr = 0.299;
    const float _Kg = 0.587;
    const float _Kb = 0.114;

    float _Y = _Kr * _Result.r + _Kg * _Result.g + _Kb * _Result.b;
    float _Cb = -0.168736 * _Result.r - 0.331264 * _Result.g + 0.5 * _Result.b + 0.5;
    float _Cr = 0.5 * _Result.r - 0.418688 * _Result.g - 0.081312 * _Result.b + 0.5;

    return vec3(_Y, _Cb, _Cr);
}

vec3 Fun_Sharp(sampler2D _Texture, vec2 _In, vec3 _Color, float _Sharpness_Size)
{
    vec3 _Result_Sharpness = 5.0 * _Color - (
                texture2D(_Texture, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Texture, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Texture, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Texture, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight)))
            ).rgb;

    return _Result_Sharpness * 0.15 + _Color * 0.85;
}

vec3 Fun_Ringing(sampler2D _Texture, vec2 _In, vec3 _Color)
{
    const int _Max = 36;
    const float _Offset = -1.0;
    const float _SampleMul = 1.5 / float(_Max);

    for(int i = _Max; i > 0; i--)
    {
        _Color += mix(_Color, texture2D(_Texture, clamp((_In + _Offset * vec2(i) * vec2(fPixelWidth, 0.0)), 0.0, 1.0)).rgb, 0.5) * _SampleMul;
    }
    
    return _Color;
}

float Fun_Hash21(vec2 _Pos) { return fract(sin(dot(_Pos, vec2(12.9898,78.233))) * 43758.5453); }
float Fun_Noise(vec2 _Pos)
{
    vec2 _I = floor(_Pos + _Seed);    vec2 _F = fract(_Pos);

        float _A = Fun_Hash21(_I + vec2(0.0, 0.0) + _Seed);
        float _B = Fun_Hash21(_I + vec2(1.0, 0.0) + _Seed);
        float _C = Fun_Hash21(_I + vec2(0.0, 1.0) + _Seed);
        float _D = Fun_Hash21(_I + vec2(1.0, 1.0) + _Seed);

    vec2 _UV = _F * _F * (3.0 - 2.0 *_F);

    return mix(mix(_A, _B, _UV.x), mix(_C, _D, _UV.x), _UV.y);
}

vec3 RGBtoHSV(vec3 _Render)
{
    float _CMax = max(_Render.r, max(_Render.g, _Render.b));
    float _CMin = min(_Render.r, min(_Render.g, _Render.b));
    float _Delta = _CMax - _CMin;

    float _H = 0.0;
    float _S = 0.0;
    float _V = _CMax;

    if (_Delta > 0.0)
    {
        _S = (_V > 0.0) ? (_Delta / _V) : 0.0;

        if (_CMax == _Render.r)
        {
            _H = 60.0 * Fun_FMod(((_Render.g - _Render.b) / _Delta), 6.0);
        }
        else if (_CMax == _Render.g)
        {
            _H = 60.0 * (((_Render.b - _Render.r) / _Delta) + 2.0);
        }
        else
        {
            _H = 60.0 * (((_Render.r - _Render.g) / _Delta) + 4.0);
        }
    }

    if (_H < 0.0) { _H += 360.0; }
    return vec3(_H, _S, _V);
}

vec3 HSVtoRGB(float _H, float _S, float _V)
{
    float _C = _V * _S;
    float _X = _C * (1.0 - abs(Fun_FMod(_H / 60.0, 2.0) - 1.0));
    float _M = _V - _C;

    vec3 _Render =      (_H < 60.0)   ? vec3(_C, _X, 0) :
                        (_H < 120.0)  ? vec3(_X, _C, 0) :
                        (_H < 180.0)  ? vec3(0, _C, _X) :
                        (_H < 240.0)  ? vec3(0, _X, _C) :
                        (_H < 300.0)  ? vec3(_X, 0, _C) :
                                        vec3(_C, 0, _X);

    return (_Render + _M);
}

void main(void)
{   
    vec2 In_Background = In;
    if (_Is_Pre_296_Build == true) In_Background = vec2(In.x, 1.0 - In.y);

    vec4 _Render_Texture = texture2D(imgTexture, In) * blendColor;
    vec4 _Render_Background = texture2D(bckgTexture, In_Background);

        vec4 _Result;

            _Result.rgb = Fun_Sharp(bckgTexture, In_Background, _Render_Background.rgb, 1.5);

                /* Noise */
                    /* Big */
                        vec2 _Noise_In = In * vec2(10.0, 80.0);

                        vec3 _Noise = vec3(Fun_Noise(_Noise_In), Fun_Noise(_Noise_In + 1.0), Fun_Noise(_Noise_In + 2.0)); _Noise.r *= _Noise.b;
                            float _Lum = Fun_Luminance(_Noise);
                            _Result.rgb += _Noise * _Lum * 0.05 * _NoiseBig;

                    /* Small (Chrominance noise) */
                        _Noise_In = In * vec2(1.6 / fPixelWidth, 1.6 / fPixelHeight);

                        _Noise = vec3(Fun_Noise(_Noise_In), Fun_Noise(_Noise_In + 1.0), Fun_Noise(_Noise_In + 2.0));
                            _Result.rgb += _Noise * _Lum * 0.22 * _NoiseSmall; 

                /* Rainbow effects */
                    float Y = Fun_Luminance(_Result.rgb);
                    float _Phase = (0.5 - abs(In.x / Y - 0.5)) * _RainbowFreq * 6.2831;

                        vec3 _Rainbow = vec3(   sin(_Phase + 0.0),  sin(_Phase + 2.094),    sin(_Phase + 4.188) );
                        vec3  _Rainbow_Pre = _RainbowStrength * _Rainbow;
                    
                    _Rainbow *= _RainbowStrength;
                    _Result.rgb += _Rainbow * Y;

                /* Ringing */
                    vec3 _Ringing = Fun_Ringing(bckgTexture, In_Background + Fun_Luminance(_Rainbow_Pre) * 0.05, _Result.rgb * _Rainbow);
                    float _Ringing_Lum = Fun_Luminance(_Ringing);

                    _Result.rgb += (_Ringing / _Rainbow) * _RainbowErrorNoise;
                    _Result.rgb += Fun_RGB_YCbCr(_Ringing + _Rainbow_Pre * 0.1) * _Ringing_Lum * _RingingMixing;

                /* Saturation */
                    vec3 _HSV = RGBtoHSV(_Result.rgb);

                    _HSV.y = (_HSV.y * (_Saturation / 50.0));
                    _HSV.z = (_HSV.z + (_Value - 50.0) / 50.0);

                    _Result.rgb = HSVtoRGB(_HSV.x, _HSV.y, _HSV.z);

                _Result.rgb = mix(_Render_Background.rgb, _Result.rgb, _Mixing);

            _Result.a = _Render_Texture.a;

    gl_FragColor = _Result;
}

//@End